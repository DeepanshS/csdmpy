<!-- 

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>csdfpy.cv &mdash; csdfpy 0.0.9alpha documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> csdfpy
          

          
            
            <img src="../../_static/csdfpy.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.0.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../requirement.html">1. The requirements for csdfpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">2. Installing <span class="guilabel">csdfpy</span> package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CSDModel.html">3. The core scientific dataset (CSD) model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Importing_csdfpy.html">4. Getting Started With <span class="guilabel">csdfpy</span> package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/examples.html">5. Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../startingFromScrach.html">6. Starting from scrach</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/A fun example.html">7. A fun ðŸ¤ª example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../referenceAPI.html">8. Reference/API documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">csdfpy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../csdfpy.html">csdfpy</a> &raquo;</li>
        
      <li>csdfpy.cv</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">

           <div itemprop="articleBody">
            
  <h1>Source code for csdfpy.cv</h1><div class="highlight"><pre>
<span></span>
<span class="sd">&quot;&quot;&quot;The base ControlledVariable object: attributes and methods.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">._gcv</span> <span class="k">import</span> <span class="n">_LinearlySampledGridDimension</span>
<span class="kn">from</span> <span class="nn">._gcv</span> <span class="k">import</span> <span class="n">_ArbitrarilySampledGridDimension</span>
<span class="kn">from</span> <span class="nn">._gcv</span> <span class="k">import</span> <span class="n">_NonQuantitativeGridDimension</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">.unit</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">_ppm</span><span class="p">,</span>
    <span class="n">string_to_unit</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">json</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">inf</span>

<span class="kn">from</span> <span class="nn">._utils</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">_assign_and_check_unit_consistency</span><span class="p">,</span>
    <span class="n">_check_unit_consistency</span><span class="p">,</span>
    <span class="n">_check_and_assign_bool</span><span class="p">,</span>
    <span class="n">_check_value_object</span><span class="p">,</span>
    <span class="n">_axis_label</span><span class="p">,</span>
    <span class="n">_type_message</span><span class="p">,</span>
    <span class="n">_attribute_message</span><span class="p">,</span>
    <span class="n">_get_dictionary</span>
<span class="p">)</span>

<span class="n">_quantitative_variable_types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Linearly sampled grid controlled variable&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;Arbitrarily sampled grid controlled variable&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_check_quantitative</span><span class="p">(</span><span class="n">dictionary</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_check_non_quantitative</span><span class="p">(</span><span class="n">dictionary</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;number_of_points&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> \
                <span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;sampling_interval&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> \
                <span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;either &#39;number_of_points, sampling_interval&#39; </span><span class="se">\</span>
<span class="s2">or &#39;values&#39; key is required.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_check_quantitative_linear</span><span class="p">(</span><span class="n">dictionary</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_check_quantitative</span><span class="p">(</span><span class="n">dictionary</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;number_of_points&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
            <span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;sampling_interval&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_check_quantitative_arbitrary</span><span class="p">(</span><span class="n">dictionary</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_check_quantitative</span><span class="p">(</span><span class="n">dictionary</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_check_non_quantitative</span><span class="p">(</span><span class="n">dictionary</span><span class="p">):</span>
    <span class="n">is_false</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;non_quantitative&#39;</span><span class="p">]:</span>
        <span class="n">is_false</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;values&#39; key is required for </span><span class="se">\</span>
<span class="s2">non-quantitative dimension.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">is_false</span>


<div class="viewcode-block" id="ControlledVariable"><a class="viewcode-back" href="../../api/csdfpy.ControlledVariable.html#csdfpy.ControlledVariable">[docs]</a><span class="k">class</span> <span class="nc">ControlledVariable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base ControlledVariable class.</span>

<span class="sd">    This class returns an object which represents a control variable. There are</span>
<span class="sd">    three types of controlled variables based on the three types ofdimensions:</span>
<span class="sd">    a linearly sampled, an arbitrarily sampled, and a</span>
<span class="sd">    non-quantitative dimension, respectively.</span>

<span class="sd">    **A linearly sampled control variable**</span>

<span class="sd">    Let :math:`m_k` be the sampling interval, :math:`N_k \ge 1` be the</span>
<span class="sd">    number of points, :math:`c_k` be the reference offset, and</span>
<span class="sd">    :math:`o_k` be the origin offset along the :math:`k^{th}`</span>
<span class="sd">    grid dimension, then the corresponding coordinates along the</span>
<span class="sd">    dimension are given as,</span>

<span class="sd">    .. math ::</span>
<span class="sd">        \begin{align}</span>
<span class="sd">        \mathbf{X}_k &amp;= [m_k j ]_{j=0}^{N_k-1} - c_k \mathbf{1}, \\</span>
<span class="sd">        \mathbf{X}_k^\mathrm{abs} &amp;= \mathbf{X}_k + o_k \mathbf{1}.</span>
<span class="sd">        \end{align}</span>
<span class="sd">        :label: eq_linear_gcv</span>

<span class="sd">    Here :math:`\mathbf{X}_k` and :math:`\mathbf{X}_k^\mathrm{abs}` are the</span>
<span class="sd">    ordered arrays of the reference and absolute control variable coordinates,</span>
<span class="sd">    respectively, and :math:`\mathbf{1}` is an array of ones.</span>

<span class="sd">    **An arbitrarily sampled control variable**</span>

<span class="sd">    Let :math:`\mathbf{A}_k` be an ordered array of ascending</span>
<span class="sd">    quantities, :math:`c_k` be the reference offset, and</span>
<span class="sd">    :math:`o_k` be the origin offset along the :math:`k^{th}`</span>
<span class="sd">    grid dimension, then the coordinates along this dimension</span>
<span class="sd">    are given as,</span>

<span class="sd">    .. math ::</span>
<span class="sd">        \begin{align}</span>
<span class="sd">        \mathbf{X}_k = \mathbf{A}_k - c_k \mathbf{1},\\</span>
<span class="sd">        \mathbf{X}_k^\mathrm{abs} = \mathbf{X}_k + o_k \mathbf{1},</span>
<span class="sd">        \end{align}</span>

<span class="sd">    where :math:`\mathbf{X}_k`, :math:`\mathbf{X}_k^\mathrm{abs}`,</span>
<span class="sd">    and :math:`\mathbf{1}` are the same as described in :eq:`eq_linear_gcv`.</span>


<span class="sd">    **A non-quantitative control variable**</span>

<span class="sd">    For non-quantitative grid dimensions, there is no reference and absolute</span>
<span class="sd">    control variable coordinates. Here, we only define the coordinate.</span>
<span class="sd">    Let :math:`\mathbf{A}_k` be an array of non-quantitative entities, then</span>
<span class="sd">    the corresponding coordinates along this dimension follow,</span>

<span class="sd">    .. math ::</span>
<span class="sd">        \mathbf{X}_k = \mathbf{A}_k.</span>

<span class="sd">    **Creating a new control variable.**</span>

<span class="sd">    There are two ways to create a new control variable using this class, but</span>
<span class="sd">    it always returns a ControlledVariable instance.</span>

<span class="sd">    `From a python dictionary containing valid keywords.` ::</span>

<span class="sd">        &gt;&gt;&gt; from csdfpy import ControlledVariable</span>
<span class="sd">        &gt;&gt;&gt; py_dictionary = {</span>
<span class="sd">        ...     &#39;sampling_interval&#39;: &#39;5 G&#39;,</span>
<span class="sd">        ...     &#39;number_of_points&#39;: 10,</span>
<span class="sd">        ...     &#39;reference_offset&#39;: &#39;-10 mT&#39;,</span>
<span class="sd">        ...     &#39;origin_offset&#39;: &#39;10 T&#39;</span>
<span class="sd">        ... }</span>
<span class="sd">        &gt;&gt;&gt; x = ControlledVariable(py_dictionary)</span>

<span class="sd">    `From valid keyword arguaments.` ::</span>

<span class="sd">        &gt;&gt;&gt; x = ControlledVariable(sampling_interval = &#39;5 G&#39;,</span>
<span class="sd">        ...                        number_of_points = 10,</span>
<span class="sd">        ...                        reference_offset = &#39;-10 mT&#39;,</span>
<span class="sd">        ...                        origin_offset = &#39;10 T&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;gcv&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new instance of ControlVariable object.&quot;&quot;&quot;</span>
        <span class="c1"># if args != () and isinstance(args[0], ControlledVariable):</span>
        <span class="c1">#     print(&#39;inside __new__. arg&#39;)</span>
        <span class="c1">#     return args[0]</span>
        <span class="c1"># else:</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">ControlledVariable</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="c1"># instance.__init__(*args, **kwargs)</span>
        <span class="k">return</span> <span class="n">instance</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of ControlVariable object.&quot;&quot;&quot;</span>
        <span class="n">dictionary</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;sampling_type&#39;</span><span class="p">:</span> <span class="s2">&quot;grid&quot;</span><span class="p">,</span>
            <span class="s1">&#39;non_quantitative&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s1">&#39;number_of_points&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;sampling_interval&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;values&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;reference_offset&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;origin_offset&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;made_dimensionless&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s1">&#39;reverse&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s1">&#39;fft_output_order&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s1">&#39;period&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;quantity&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;reciprocal&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;sampling_interval&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;reference_offset&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;origin_offset&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;made_dimensionless&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;reverse&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;period&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;quantity&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">}</span>
        <span class="p">}</span>

        <span class="n">default_keys</span> <span class="o">=</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">input_dict</span> <span class="o">=</span> <span class="n">_get_dictionary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">input_keys</span> <span class="o">=</span> <span class="n">input_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="k">if</span> <span class="s1">&#39;reciprocal&#39;</span> <span class="ow">in</span> <span class="n">input_keys</span><span class="p">:</span>
            <span class="n">input_subkeys</span> <span class="o">=</span> <span class="n">input_dict</span><span class="p">[</span><span class="s1">&#39;reciprocal&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">input_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">default_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;reciprocal&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">subkey</span> <span class="ow">in</span> <span class="n">input_subkeys</span><span class="p">:</span>
                        <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">subkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">subkey</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># print(dictionary)</span>

        <span class="k">if</span> <span class="n">_check_non_quantitative</span><span class="p">(</span><span class="n">dictionary</span><span class="p">):</span>
            <span class="n">_gcv_object</span> <span class="o">=</span> <span class="n">_NonQuantitativeGridDimension</span><span class="p">(</span>
                    <span class="n">_sampling_type</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;sampling_type&#39;</span><span class="p">],</span>
                    <span class="n">_non_quantitative</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;non_quantitative&#39;</span><span class="p">],</span>
                    <span class="n">_values</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">],</span>
                    <span class="n">_reverse</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reverse&#39;</span><span class="p">],</span>
                    <span class="n">_label</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="n">_check_quantitative_arbitrary</span><span class="p">(</span><span class="n">dictionary</span><span class="p">):</span>
            <span class="n">_gcv_object</span> <span class="o">=</span> <span class="n">_ArbitrarilySampledGridDimension</span><span class="p">(</span>

                <span class="n">_sampling_type</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;sampling_type&#39;</span><span class="p">],</span>
                <span class="n">_non_quantitative</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;non_quantitative&#39;</span><span class="p">],</span>

                <span class="n">_values</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">],</span>
                <span class="n">_reference_offset</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reference_offset&#39;</span><span class="p">],</span>
                <span class="n">_origin_offset</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;origin_offset&#39;</span><span class="p">],</span>
                <span class="n">_quantity</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;quantity&#39;</span><span class="p">],</span>
                <span class="n">_reverse</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reverse&#39;</span><span class="p">],</span>
                <span class="n">_label</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">],</span>
                <span class="n">_period</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;period&#39;</span><span class="p">],</span>
                <span class="n">_made_dimensionless</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;made_dimensionless&#39;</span><span class="p">],</span>

                <span class="n">_reciprocal_reference_offset</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reciprocal&#39;</span><span class="p">]</span>
                                                       <span class="p">[</span><span class="s1">&#39;reference_offset&#39;</span><span class="p">],</span>
                <span class="n">_reciprocal_origin_offset</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reciprocal&#39;</span><span class="p">]</span>
                                                    <span class="p">[</span><span class="s1">&#39;origin_offset&#39;</span><span class="p">],</span>
                <span class="n">_reciprocal_quantity</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reciprocal&#39;</span><span class="p">][</span><span class="s1">&#39;quantity&#39;</span><span class="p">],</span>
                <span class="n">_reciprocal_reverse</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reciprocal&#39;</span><span class="p">][</span><span class="s1">&#39;reverse&#39;</span><span class="p">],</span>
                <span class="n">_reciprocal_period</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reciprocal&#39;</span><span class="p">][</span><span class="s1">&#39;period&#39;</span><span class="p">],</span>
                <span class="n">_reciprocal_label</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reciprocal&#39;</span><span class="p">][</span><span class="s1">&#39;label&#39;</span><span class="p">],</span>
                <span class="n">_reciprocal_made_dimensionless</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span>
                                                <span class="s1">&#39;reciprocal&#39;</span><span class="p">][</span>
                                                <span class="s1">&#39;made_dimensionless&#39;</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">_check_quantitative_linear</span><span class="p">(</span><span class="n">dictionary</span><span class="p">):</span>
            <span class="n">_gcv_object</span> <span class="o">=</span> <span class="n">_LinearlySampledGridDimension</span><span class="p">(</span>
                <span class="n">_sampling_type</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;sampling_type&#39;</span><span class="p">],</span>
                <span class="n">_non_quantitative</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;non_quantitative&#39;</span><span class="p">],</span>

                <span class="n">_number_of_points</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;number_of_points&#39;</span><span class="p">],</span>
                <span class="n">_sampling_interval</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;sampling_interval&#39;</span><span class="p">],</span>
                <span class="n">_reference_offset</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reference_offset&#39;</span><span class="p">],</span>
                <span class="n">_origin_offset</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;origin_offset&#39;</span><span class="p">],</span>
                <span class="n">_quantity</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;quantity&#39;</span><span class="p">],</span>
                <span class="n">_reverse</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reverse&#39;</span><span class="p">],</span>
                <span class="n">_label</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">],</span>
                <span class="n">_period</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;period&#39;</span><span class="p">],</span>
                <span class="n">_fft_output_order</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;fft_output_order&#39;</span><span class="p">],</span>
                <span class="n">_made_dimensionless</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;made_dimensionless&#39;</span><span class="p">],</span>

                <span class="n">_reciprocal_sampling_interval</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reciprocal&#39;</span><span class="p">]</span>
                                                        <span class="p">[</span><span class="s1">&#39;sampling_interval&#39;</span><span class="p">],</span>
                <span class="n">_reciprocal_reference_offset</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reciprocal&#39;</span><span class="p">]</span>
                                                       <span class="p">[</span><span class="s1">&#39;reference_offset&#39;</span><span class="p">],</span>
                <span class="n">_reciprocal_origin_offset</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reciprocal&#39;</span><span class="p">]</span>
                                                    <span class="p">[</span><span class="s1">&#39;origin_offset&#39;</span><span class="p">],</span>
                <span class="n">_reciprocal_quantity</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reciprocal&#39;</span><span class="p">][</span><span class="s1">&#39;quantity&#39;</span><span class="p">],</span>
                <span class="n">_reciprocal_reverse</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reciprocal&#39;</span><span class="p">][</span><span class="s1">&#39;reverse&#39;</span><span class="p">],</span>
                <span class="n">_reciprocal_period</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reciprocal&#39;</span><span class="p">][</span><span class="s1">&#39;period&#39;</span><span class="p">],</span>
                <span class="n">_reciprocal_label</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;reciprocal&#39;</span><span class="p">][</span><span class="s1">&#39;label&#39;</span><span class="p">],</span>
                <span class="n">_reciprocal_made_dimensionless</span><span class="o">=</span><span class="n">dictionary</span><span class="p">[</span>
                                                <span class="s1">&#39;reciprocal&#39;</span><span class="p">][</span>
                                                <span class="s1">&#39;made_dimensionless&#39;</span><span class="p">])</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">ControlledVariable</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;gcv&#39;</span><span class="p">,</span> <span class="n">_gcv_object</span><span class="p">)</span>

<span class="c1">#               Attributes defining the controlled variable type              #</span>
<span class="c1"># --------------------------------------------------------------------------- #</span>

<span class="c1"># Variables type #</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">variable_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the control variable type.</span>

<span class="sd">        There are three types of controlled variables base on the types of</span>
<span class="sd">        dimensions, linearly and arbitrarily sampled quantitative grid</span>
<span class="sd">        dimensions and non-quantitative dimension.</span>
<span class="sd">        This attribute cannot be modified. ::</span>

<span class="sd">            &gt;&gt;&gt; print(x.variable_type)</span>
<span class="sd">            Linearly sampled grid controlled variable</span>

<span class="sd">        In the above example, ``x`` is an instance of the ControlledVariable</span>
<span class="sd">        class associated with a linearly sampled controlled variable.</span>

<span class="sd">        :returns: A string.</span>
<span class="sd">        :raises AttributeError: When the attribute is modified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">variable_type</span><span class="p">)</span>

<span class="c1">#           Attributes defining the control variable sampling type            #</span>
<span class="c1"># --------------------------------------------------------------------------- #</span>

<span class="c1"># Sampling type #</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sampling_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return sampling type of the controlled variable.</span>

<span class="sd">        This attribute cannot be modified. ::</span>

<span class="sd">            &gt;&gt;&gt; print(x.sampling_type)</span>
<span class="sd">            grid</span>

<span class="sd">        :returns: A string.</span>
<span class="sd">        :raises AttributeError: When the attribute is modified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_sampling_type</span><span class="p">)</span>

<span class="c1"># =========================================================================== #</span>
<span class="c1">#                             Derived Attributes                              #</span>
<span class="c1"># =========================================================================== #</span>

<span class="c1"># coordinates #</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array of reference coordinates, :math:`\mathbf{X}_k`, along the dimension.</span>

<span class="sd">        The order of these coordinates</span>
<span class="sd">        depends on the value of the ``reverse`` and the ``fft_output_order``</span>
<span class="sd">        (only applicable when sampling is linear along the dimension)</span>
<span class="sd">        attributes of the class. This attribute cannot be modified. ::</span>

<span class="sd">            &gt;&gt;&gt; print(x.coordinates)</span>
<span class="sd">            [100. 105. 110. 115. 120. 125. 130. 135. 140. 145.] G</span>

<span class="sd">        :returns: A ``Quantity array`` when the controlled variable is</span>
<span class="sd">                  quantitative.</span>
<span class="sd">        :returns: A ``Numpy array`` when the controlled variable is</span>
<span class="sd">                  non-quantitative.</span>
<span class="sd">        :raises AttributeError: When the attribute is modified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">coordinates</span>

<span class="c1"># absolute_coordinates</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">absolute_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array of absolute coordinates, :math:`\mathbf{X}_k^\mathrm{abs}`, along the dimension.</span>

<span class="sd">        This attribute is</span>
<span class="sd">        only `valid` for the quantitative controlled variables. The order of</span>
<span class="sd">        these coordinates depends on the value of the ``reverse`` and the</span>
<span class="sd">        ``fft_output_order`` (only applicable when sampling is linear along</span>
<span class="sd">        the dimension) attributes of the class. This attribute cannot be</span>
<span class="sd">        modified. ::</span>

<span class="sd">            &gt;&gt;&gt; print(x.origin_offset)</span>
<span class="sd">            10.0 T</span>
<span class="sd">            &gt;&gt;&gt; print(x.absolute_coordinates)</span>
<span class="sd">            [100100. 100105. 100110. 100115. 100120. 100125. 100130. 100135. 100140. 100145.] G</span>

<span class="sd">        In the above example, the absolute coordinate is ``coordinates</span>
<span class="sd">        + origin_offset``.</span>

<span class="sd">        :returns: A ``Quantity array`` when the controlled</span>
<span class="sd">                  variable is quantitative.</span>
<span class="sd">        :raises AttributeError: For non-quantitative controlled variables.</span>
<span class="sd">        :raises AttributeError: When the attribute is modified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">+</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_origin_offset</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                <span class="s1">&#39;absolute_coordinates&#39;</span><span class="p">))</span>

<span class="c1"># reciprocal_coordinates</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reciprocal_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array of coordinates, :math:`\mathbf{X_r}_k^\mathrm{abs}`, along the reciprocal dimension.</span>

<span class="sd">        This attribute is</span>
<span class="sd">        only `valid` for the quantitative controlled variabes. The order of</span>
<span class="sd">        these coordinates depends on the value of the ``reciprocal_reverse``</span>
<span class="sd">        attributes of the class. This attribute cannot be modified.</span>

<span class="sd">        :returns: A ``Quantity`` object when the controlled</span>
<span class="sd">                  variable is quantitative.</span>
<span class="sd">        :raises AttributeError: For non-quantitative controlled variables.</span>
<span class="sd">        :raises AttributeError: When the attribute is modified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">reciprocal_coordinates</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                <span class="s1">&#39;reciprocal_coordinates&#39;</span><span class="p">))</span>

<span class="c1"># reciprocal_absolute_coordinates</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reciprocal_absolute_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array of absolute coordinates, :math:`\mathbf{X_r}_k^\mathrm{abs}`, along the reciprocal dimension.</span>

<span class="sd">        This attribute is only `valid` for the quantitative controlled</span>
<span class="sd">        variabes. The order of these coordinates depends on the value of the</span>
<span class="sd">        ``reciprocal_reverse`` attributes of the class. This attribute cannot</span>
<span class="sd">        be modified.</span>

<span class="sd">        :returns: A ``Quantity`` object when the controlled</span>
<span class="sd">                  variable is quantitative.</span>
<span class="sd">        :raises AttributeError: For non-quantitative controlled variables.</span>
<span class="sd">        :raises AttributeError: When the attribute is modified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">reciprocal_coordinates</span> <span class="o">+</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_reciprocal_origin_offset</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">reciprocal_unit</span><span class="p">)</span>

<span class="c1"># =========================================================================== #</span>
<span class="c1">#           Attributes affecting the controlled variable coordinates          #</span>
<span class="c1"># =========================================================================== #</span>

<span class="c1"># reference offset</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reference_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the reference offset, :math:`c_k`, along the dimension.</span>

<span class="sd">        The attribute is only `valid` for quantitative</span>
<span class="sd">        dimensions. When assigning a value, the dimensionality of the value</span>
<span class="sd">        must be consistent with the dimensionality of the other members</span>
<span class="sd">        specifying the dimension. The value is assigned with a string</span>
<span class="sd">        containing the reference offset,</span>
<span class="sd">        for example, ::</span>

<span class="sd">            &gt;&gt;&gt; print(x.reference_offset)</span>
<span class="sd">            -10.0 mT</span>
<span class="sd">            &gt;&gt;&gt; x.reference_offset = &quot;0 T&quot;</span>
<span class="sd">            &gt;&gt;&gt; print(x.coordinates)</span>
<span class="sd">            [ 0.  5. 10. 15. 20. 25. 30. 35. 40. 45.] G</span>

<span class="sd">        :returns: A ``Quantity`` object with the reference offset.</span>
<span class="sd">        :raises AttributeError: For non-quantitative controlled variables.</span>
<span class="sd">        :raises TypeError: When the assigned value is not a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_reference_offset</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                <span class="s1">&#39;reference_offset&#39;</span><span class="p">))</span>

    <span class="nd">@reference_offset</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">reference_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_type_message</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>

            <span class="n">_value</span> <span class="o">=</span> <span class="n">_assign_and_check_unit_consistency</span><span class="p">(</span>
                <span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">unit</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;_reference_offset&#39;</span><span class="p">,</span> <span class="n">_value</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                <span class="s1">&#39;reference_offset&#39;</span><span class="p">))</span>

<span class="c1"># reciprocal reference offset</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reciprocal_reference_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the reference offset along the reciprocal dimension.</span>

<span class="sd">        This attribute is only `valid` for the quantitative</span>
<span class="sd">        dimensions. When assigning a value, the dimensionality of the value</span>
<span class="sd">        must be consistent with the dimensionality of other members</span>
<span class="sd">        specifying the reciprocal dimension. The value is assigned with a</span>
<span class="sd">        string containing the reference offset of the reciprocal</span>
<span class="sd">        dimension, for example, ::</span>

<span class="sd">            &gt;&gt;&gt; print(x.reciprocal_reference_offset)</span>
<span class="sd">            0.0 1 / G</span>
<span class="sd">            &gt;&gt;&gt; x.reciprocal_reference_offset = &quot;5 (1/T)&quot;</span>

<span class="sd">        :returns: A ``Quantity`` object with the reference offset</span>
<span class="sd">                  of the reciprocal dimension.</span>
<span class="sd">        :raises TypeError: When the assigned value is not a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_reciprocal_reference_offset</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="n">_attribute_message</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span> <span class="s1">&#39;reciprocal_reference_offset&#39;</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@reciprocal_reference_offset</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">reciprocal_reference_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_type_message</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>

            <span class="n">_value</span> <span class="o">=</span> <span class="n">_assign_and_check_unit_consistency</span><span class="p">(</span>
                <span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">reciprocal_unit</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;_reciprocal_reference_offset&#39;</span><span class="p">,</span> <span class="n">_value</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="n">_attribute_message</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span> <span class="s1">&#39;reciprocal_reference_offset&#39;</span><span class="p">)</span>
        <span class="p">)</span>
<span class="c1"># --------------------------------------------------------------------------- #</span>

<span class="c1"># origin offset</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the origin offset, :math:`o_k`, along the dimension.</span>

<span class="sd">        The attribute is only `valid` for quantitative</span>
<span class="sd">        dimensions. When assigning a value, the dimensionality of the value</span>
<span class="sd">        must be consistent with the dimensionality of other members specifying</span>
<span class="sd">        the dimension. The value is assigned with a string containing the</span>
<span class="sd">        origin offset, for example, ::</span>

<span class="sd">            &gt;&gt;&gt; print(x.origin_offset)</span>
<span class="sd">            10.0 T</span>
<span class="sd">            &gt;&gt;&gt; x.origin_offset = &quot;1e5 G&quot;</span>
<span class="sd">            &gt;&gt;&gt; print(x.absolute_coordinates)</span>
<span class="sd">            [100000. 100005. 100010. 100015. 100020. 100025. 100030. 100035. 100040. 100045.] G</span>

<span class="sd">        :returns: A ``Quantity`` object with the origin offset.</span>
<span class="sd">        :raises AttributeError: For non-quantitative controlled variables.</span>
<span class="sd">        :raises TypeError: When the assigned value is not a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_origin_offset</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                <span class="s1">&#39;origin_offset&#39;</span><span class="p">))</span>

    <span class="nd">@origin_offset</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">origin_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_type_message</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>

            <span class="n">_value</span> <span class="o">=</span> <span class="n">_assign_and_check_unit_consistency</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;_origin_offset&#39;</span><span class="p">,</span> <span class="n">_value</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                <span class="s1">&#39;origin_offset&#39;</span><span class="p">))</span>

<span class="c1"># reciprocal origin offset</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reciprocal_origin_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the origin offset along the reciprocal dimension.</span>

<span class="sd">        This attribute is only `valid` for the quantitative dimensions. When</span>
<span class="sd">        assigning a value, the dimensionality of the value must be consistent</span>
<span class="sd">        with the dimensionality of the other members specifying the reciprocal</span>
<span class="sd">        dimension. The value is assigned with a string containing the origin</span>
<span class="sd">        offset of the reciprocal dimension, for example, ::</span>

<span class="sd">            &gt;&gt;&gt; print(x.reciprocal_origin_offset)</span>
<span class="sd">            0.0 1 / G</span>
<span class="sd">            &gt;&gt;&gt; x.reciprocal_origin_offset = &quot;400 (1/ÂµT)&quot;</span>

<span class="sd">        :returns: A ``Quantity`` object with the origin offset of</span>
<span class="sd">                  the reciprocal dimension.</span>
<span class="sd">        :raises AttributeError: For non-quantitative controlled variables.</span>
<span class="sd">        :raises TypeError: When the assigned value is not a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_reciprocal_origin_offset</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                <span class="s1">&#39;reciprocal_origin_offset&#39;</span><span class="p">))</span>

    <span class="nd">@reciprocal_origin_offset</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">reciprocal_origin_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_type_message</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>

            <span class="n">_value</span> <span class="o">=</span> <span class="n">_assign_and_check_unit_consistency</span><span class="p">(</span>
                <span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">reciprocal_unit</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;_reciprocal_origin_offset&#39;</span><span class="p">,</span> <span class="n">_value</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                <span class="s1">&#39;reciprocal_origin_offset&#39;</span><span class="p">))</span>
<span class="c1"># --------------------------------------------------------------------------- #</span>

<span class="c1"># sampling interval</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sampling_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sampling interval, :math:`m_k`, along the dimension.</span>

<span class="sd">        The attribute is only `valid` for instances with linearly sampled</span>
<span class="sd">        controlled-variable dimensions. When assigning a value,</span>
<span class="sd">        the dimensionality of the value must be consistent with the</span>
<span class="sd">        dimensionality of other members specifying the grid dimension.</span>
<span class="sd">        Additionally, the sampling interval must be a positive real number.</span>
<span class="sd">        The value is assigned with a string containing the sampling interval,</span>
<span class="sd">        for example, ::</span>

<span class="sd">            &gt;&gt;&gt; print(x.sampling_interval)</span>
<span class="sd">            5.0 G</span>
<span class="sd">            &gt;&gt;&gt; x.sampling_interval = &quot;0.1 G&quot;</span>
<span class="sd">            &gt;&gt;&gt; print(x.coordinates)</span>
<span class="sd">            [0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9] G</span>

<span class="sd">        Here, the original sampling interval, &#39;5 G&#39; is modified to</span>
<span class="sd">        &#39;0.1 G&#39;.</span>

<span class="sd">        .. note:: The sampling interval along a grid dimension and the</span>
<span class="sd">            respective reciprocal grid dimension follow the Nyquistâ€“Shannon</span>
<span class="sd">            sampling theorem. Therefore, updating the ``sampling_interval``</span>
<span class="sd">            will automatically trigger an update on its reciprocal counterpart.</span>

<span class="sd">        :returns: A ``Quantity`` object with the sampling interval.</span>
<span class="sd">        :raises AttributeError: For non-quantitative and arbitrarily</span>
<span class="sd">                                sampled controlled variables.</span>
<span class="sd">        :raises TypeError: When the assigned value is not a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="o">==</span> <span class="n">_quantitative_variable_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_sampling_interval</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                <span class="s1">&#39;sampling_interval&#39;</span><span class="p">))</span>

    <span class="nd">@sampling_interval</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">sampling_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="o">==</span> <span class="n">_quantitative_variable_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_type_message</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">sampling_interval</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                <span class="s1">&#39;sampling_interval&#39;</span><span class="p">))</span>
<span class="c1"># --------------------------------------------------------------------------- #</span>

<span class="c1"># number_of_points</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">number_of_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of points along the dimension.</span>

<span class="sd">        The number of points, :math:`N_k \ge 1`, along the controlled</span>
<span class="sd">        variable dimension. The attribute is updated with an</span>
<span class="sd">        integer specifying the number of points, for example ::</span>

<span class="sd">            &gt;&gt;&gt; print(x.number_of_points)</span>
<span class="sd">            10</span>
<span class="sd">            &gt;&gt;&gt; x.number_of_points = 5</span>
<span class="sd">            &gt;&gt;&gt; print(x.coordinates)</span>
<span class="sd">            [0.  0.1 0.2 0.3 0.4] G</span>

<span class="sd">        :returns: An ``Integer`` with the number of points.</span>
<span class="sd">        :raises TypeError: When the assigned value is not an integer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_number_of_points</span><span class="p">)</span>

    <span class="nd">@number_of_points</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">number_of_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_type_message</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="s2">&quot;An positive integer value is required, &quot;</span>
                    <span class="s2">&quot;a value of </span><span class="si">{0}</span><span class="s2"> is provided.&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="o">!=</span> <span class="n">_quantitative_variable_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_points</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;Cannot set the number of points, </span><span class="si">{0}</span><span class="s2">, more &quot;</span>
                        <span class="s2">&quot;than the number of controlled variable coordinates, &quot;</span>
                        <span class="s2">&quot;</span><span class="si">{1}</span><span class="s2">, when sampled arbitrarily along the dimension.&quot;</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_points</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_points</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;The number of controlled variable &quot;</span>
                        <span class="s2">&quot;coordinates, </span><span class="si">{0}</span><span class="s2">, are truncated to </span><span class="si">{1}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_points</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;_number_of_points&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;_number_of_points&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_get_coordinates</span><span class="p">()</span>
<span class="c1"># --------------------------------------------------------------------------- #</span>

<span class="c1"># values arrat</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the values along the dimension.</span>

<span class="sd">        An ordered array, :math:`\mathbf{A}_k`, of strings</span>
<span class="sd">        containing the values. Depending on the values, either a</span>
<span class="sd">        quantitative or a non-quantitative controlled variable dimension</span>
<span class="sd">        is created. For example,</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{A}_k = [\mathrm{&quot;0~cm&quot;}, \mathrm{&quot;4.1~Âµm&quot;},</span>
<span class="sd">            \mathrm{&quot;0.3~mm&quot;}, \mathrm{&quot;5.8~m&quot;}, \mathrm{&quot;32.4~km&quot;}]</span>

<span class="sd">        will generate an arbitrarily sampled controlled variable dimension,</span>
<span class="sd">        while,</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{A}_k = [\mathrm{&quot;Cu&quot;}, \mathrm{&quot;Ag&quot;}, \mathrm{&quot;Au&quot;}]</span>

<span class="sd">        will generate a non-quantitative dimension. For</span>
<span class="sd">        an arbitrarily sampled quantitative variables,</span>
<span class="sd">        :math:`\mathbf{A}_k` is an ascending order of quantities. ::</span>

<span class="sd">            &gt;&gt;&gt; x1 = ControlledVariable(values=[&#39;cm&#39;])</span>
<span class="sd">            &gt;&gt;&gt; x1.values = [&#39;0cm&#39;, &#39;4.1Âµm&#39;, &#39;0.3mm&#39;, &#39;5.8m&#39;, &#39;32.4km&#39;]</span>

<span class="sd">            &gt;&gt;&gt; x2 = ControlledVariable(values=[&#39;&#39;], non_quantitative=True)</span>
<span class="sd">            &gt;&gt;&gt; x2.values = [&#39;Cu&#39;, &#39;Ag&#39;, &#39;Au&#39;]</span>

<span class="sd">        In the above examples, ``x1`` and ``x2`` are the instances of the</span>
<span class="sd">        ControlledVariable class associated with the arbitrarily sampled</span>
<span class="sd">        and the non-quantitative controlled variable respectively.</span>

<span class="sd">        :returns: A ``Quantity array`` for arbitrarily sampled controlled</span>
<span class="sd">                        variables.</span>
<span class="sd">        :returns: A ``Numpy array`` for non-quantitative controlled variables.</span>
<span class="sd">        :raises AttributeError: For linearly sampled controlled variables.</span>

<span class="sd">        .. todo:</span>
<span class="sd">            raise type error if the values are not strings or numpy array</span>
<span class="sd">            of stings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="o">==</span> <span class="n">_quantitative_variable_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                    <span class="s1">&#39;values&#39;</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>

    <span class="nd">@values</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="o">==</span> <span class="n">_quantitative_variable_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                    <span class="s1">&#39;values&#39;</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_get_coordinates</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

<span class="c1"># ===================================================================== #</span>
<span class="c1"># Attributes affecting the order of the controlled variable coordinates #</span>
<span class="c1"># ===================================================================== #</span>

<span class="c1"># fft_ouput_order</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fft_output_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the coordinates along the dimension according to the fft order.</span>

<span class="sd">        A boolean specifying if the coordinates along the controlled</span>
<span class="sd">        variable dimension are ordered according to the output of a</span>
<span class="sd">        fast Fourier transform (FFT) routine. This attribute is only</span>
<span class="sd">        *valid* for linearly sampled controlled variable dimensions. The</span>
<span class="sd">        universal behavior of the FFT routine is to order the :math:`N_k`</span>
<span class="sd">        output amplitudes by placing the zero `frequency` at the start</span>
<span class="sd">        of the output array, with positive `frequencies` increasing in</span>
<span class="sd">        magnitude placed at increasing array offset until reaching</span>
<span class="sd">        :math:`\frac{N_k}{2} -1` if :math:`N_k` is even, otherwise</span>
<span class="sd">        :math:`\frac{N_k-1}{2}`, followed by negative frequencies</span>
<span class="sd">        decreasing in magnitude until reaching :math:`N_k-1`.</span>
<span class="sd">        This is also the ordering needed for the input of the inverse FFT.</span>
<span class="sd">        For example, consider</span>

<span class="sd">        .. math ::</span>
<span class="sd">            \mathbf{X}_k^\mathrm{ref} = [0, 1, 2, 3, 4, 5] \mathrm{~m/s}</span>

<span class="sd">        when the fft output order is false. When the fft output</span>
<span class="sd">        order is true, the order follows,</span>

<span class="sd">        .. math ::</span>
<span class="sd">            \mathbf{X}_k^\mathrm{ref} = [0 ,1, 2, -3, -2, -1] \mathrm{~m/s}</span>

<span class="sd">        The following is a test example. ::</span>

<span class="sd">            &gt;&gt;&gt; test = ControlledVariable(sampling_interval = &#39;1&#39;,</span>
<span class="sd">            ...                           number_of_points = 10)</span>

<span class="sd">            &gt;&gt;&gt; print(test.coordinates)</span>
<span class="sd">            [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]</span>
<span class="sd">            &gt;&gt;&gt; test.fft_output_order</span>
<span class="sd">            False</span>

<span class="sd">            &gt;&gt;&gt; test.fft_output_order = True</span>
<span class="sd">            &gt;&gt;&gt; print(test.coordinates)</span>
<span class="sd">            [ 0.  1.  2.  3.  4. -5. -4. -3. -2. -1.]</span>

<span class="sd">        :returns: A ``Boolean``.</span>
<span class="sd">        :raises TypeError: When the assigned value is not a boolean.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="o">==</span> <span class="n">_quantitative_variable_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_fft_output_order</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                <span class="s1">&#39;fft_output_order&#39;</span><span class="p">))</span>

    <span class="nd">@fft_output_order</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">fft_output_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="o">==</span> <span class="n">_quantitative_variable_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_type_message</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>

            <span class="c1"># print(&#39;in fft output order&#39;)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;_fft_output_order&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_get_coordinates</span><span class="p">()</span>
            <span class="k">return</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                <span class="s1">&#39;fft_output_order&#39;</span><span class="p">))</span>
<span class="c1"># --------------------------------------------------------------------------- #</span>

<span class="c1"># reverse</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the coordinates along the dimension in the reverse order.</span>

<span class="sd">        The order in which the :math:`\mathbf{X}_k` and</span>
<span class="sd">        :math:`\mathbf{X}_k^\mathrm{abs}` coordinates map to the grid indices,</span>
<span class="sd">        :math:`\mathbf{G}_k = [0,1,2,...,N_k-1]`. For example, consider</span>

<span class="sd">        .. math ::</span>
<span class="sd">            \mathbf{X}_k^\mathrm{ref} = [0, 1, 2, 3,...N_{k-1}] \mathrm{~m/s},</span>

<span class="sd">        when the reverse is false. We the reverse is true, the mapping is</span>

<span class="sd">        .. math ::</span>
<span class="sd">            \mathbf{X}_k^\mathrm{ref} = [N_{k-1},...3, 2, 1, 0] \mathrm{~m/s}.</span>

<span class="sd">            &gt;&gt;&gt; x.reverse</span>
<span class="sd">            False</span>
<span class="sd">            &gt;&gt;&gt; print(x.coordinates)</span>
<span class="sd">            [0.  0.1 0.2 0.3 0.4] G</span>
<span class="sd">            &gt;&gt;&gt; x.reverse = True</span>
<span class="sd">            &gt;&gt;&gt; print(x.coordinates)</span>
<span class="sd">            [0.4 0.3 0.2 0.1 0. ] G</span>

<span class="sd">        :returns: A ``Boolean``.</span>
<span class="sd">        :raises TypeError: When the assigned value is not a boolean.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_reverse</span><span class="p">)</span>

    <span class="nd">@reverse</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_type_message</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>

        <span class="n">_value</span> <span class="o">=</span> <span class="n">_check_and_assign_bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;_reverse&#39;</span><span class="p">,</span> <span class="n">_value</span><span class="p">)</span>

<span class="c1"># reciprocal reverse</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reciprocal_reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the coordinates along the reciprocal dimension in reverse order.</span>

<span class="sd">        The order in which the :math:`\mathbf{X_r}_k` and</span>
<span class="sd">        :math:`\mathbf{X_r}_k^\mathrm{abs}` (for quantitative dimensions)</span>
<span class="sd">        coordinates are mapped to the grid indices. Let, the grid</span>
<span class="sd">        indices be :math:`[0,1,2,...,N_k-1]`, then when reverse</span>
<span class="sd">        is false, the mapping follows,</span>

<span class="sd">        .. math ::</span>
<span class="sd">            \mathbf{X}_k^\mathrm{ref} = [0, 1, 2, 3, 4] \mathrm{~s/m}</span>

<span class="sd">        and when reverse is false, then the mapping is</span>

<span class="sd">        .. math ::</span>
<span class="sd">            \mathbf{X}_k^\mathrm{ref} = [4, 3, 2, 1, 0] \mathrm{~s/m}</span>

<span class="sd">        :returns: A ``boolean``.</span>
<span class="sd">        :raises TypeError: When the assigned value is not a boolean.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_reciprocal_reverse</span><span class="p">)</span>

    <span class="nd">@reciprocal_reverse</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">reciprocal_reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_type_message</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>

        <span class="n">_value</span> <span class="o">=</span> <span class="n">_check_and_assign_bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;_reciprocal_reverse&#39;</span><span class="p">,</span> <span class="n">_value</span><span class="p">)</span>

<span class="c1"># =========================================================================== #</span>
<span class="c1">#                            Additional Attributes                            #</span>
<span class="c1"># =========================================================================== #</span>

<span class="c1"># period</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">period</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the period of a quantitative controlled variable dimension.</span>

<span class="sd">        The default value of the period is infinity, i.e., the controlled</span>
<span class="sd">        variable dimension is non-periodic. The attribute is updated with a</span>
<span class="sd">        string containing a quantity which represents the period of the</span>
<span class="sd">        controlled variable. For example, ::</span>

<span class="sd">            &gt;&gt;&gt; print(x.period)</span>
<span class="sd">            inf G</span>
<span class="sd">            &gt;&gt;&gt; x.period = &#39;1 T&#39;</span>

<span class="sd">        To assign a dimension as non-periodic, one of the following may be</span>
<span class="sd">        used, ::</span>

<span class="sd">            &gt;&gt;&gt; x.period = &#39;1/0 T&#39;</span>
<span class="sd">            &gt;&gt;&gt; x.period = &#39;infinity ÂµT&#39;</span>
<span class="sd">            &gt;&gt;&gt; x.period = &#39;âˆž G&#39;</span>

<span class="sd">        :return: A ``Quantity`` object with the period of quantitative</span>
<span class="sd">            controlled variables.</span>
<span class="sd">        :raises AttributeError: For non-quantitative controlled variables.</span>
<span class="sd">        :raises TypeError: When the assigned value is not a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_period</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span> <span class="s1">&#39;period&#39;</span><span class="p">))</span>

    <span class="nd">@period</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">period</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_type_message</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>

            <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;inf&#39;</span><span class="p">,</span> <span class="s1">&#39;Inf&#39;</span><span class="p">,</span> <span class="s1">&#39;infinity&#39;</span><span class="p">,</span> <span class="s1">&#39;Infinity&#39;</span><span class="p">,</span> <span class="s1">&#39;âˆž&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">inf</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">unit</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;_period&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span>
                    <span class="s1">&#39;_period&#39;</span><span class="p">,</span> <span class="n">_check_value_object</span><span class="p">(</span>
                        <span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span> <span class="s1">&#39;period&#39;</span><span class="p">))</span>

<span class="c1"># reciprocal period</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reciprocal_period</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the period of the reciprocal dimension.</span>

<span class="sd">        The period of the reciprocal controlled variable along</span>
<span class="sd">        the dimension, if any. The default value is infinity,</span>
<span class="sd">        that is, the reciprocal dimension is considered non-periodic.</span>
<span class="sd">        This attribute can be updated with a string containing</span>
<span class="sd">        a physical quantity representing the period, for example,</span>
<span class="sd">        the reciprocal_period of &quot;0.1 h/km&quot;. A period of &quot;1/0 h/km&quot;</span>
<span class="sd">        or &quot;inf h/km&quot; or &quot;infinity h/km&quot; will make the dimension</span>
<span class="sd">        non-periodic.</span>

<span class="sd">        :return: A ``Quantity`` object with physical quantity</span>
<span class="sd">                 representing a period.</span>
<span class="sd">        :raises AttributeError: For non-quantitative controlled variables.</span>
<span class="sd">        :raises TypeError: When the assigned value is not a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_reciprocal_period</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                <span class="s1">&#39;reciprocal_period&#39;</span><span class="p">))</span>

    <span class="nd">@reciprocal_period</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">reciprocal_period</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_type_message</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>

            <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;inf&#39;</span><span class="p">,</span> <span class="s1">&#39;Inf&#39;</span><span class="p">,</span> <span class="s1">&#39;infinity&#39;</span><span class="p">,</span> <span class="s1">&#39;Infinity&#39;</span><span class="p">,</span> <span class="s1">&#39;âˆž&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">inf</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">reciprocal_unit</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;_reciprocal_period&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span>
                    <span class="s1">&#39;_reciprocal_period&#39;</span><span class="p">,</span> <span class="n">_check_value_object</span><span class="p">(</span>
                        <span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">reciprocal_unit</span><span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                <span class="s1">&#39;reciprocal_period&#39;</span><span class="p">))</span>
<span class="c1"># --------------------------------------------------------------------------- #</span>

<span class="c1"># Quantity</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">quantity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the quantity name associated with the dimension.</span>

<span class="sd">        The attribute is only `valid` for the quantitative</span>
<span class="sd">        controlled variables. ::</span>

<span class="sd">            &gt;&gt;&gt; print(x.quantity)</span>
<span class="sd">            magnetic flux density</span>

<span class="sd">        :returns: A string with the quantity name.</span>
<span class="sd">        :raises AttributeError: For non-quantitative controlled variables.</span>
<span class="sd">        :raises NotImplementedError: When assigning a value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_quantity</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                <span class="s1">&#39;quantity&#39;</span><span class="p">))</span>

    <span class="nd">@quantity</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">quantity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;This attribute is not yet implemented.&#39;</span><span class="p">)</span>

<span class="c1"># reciprocal Quantity</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reciprocal_quantity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the quantity name associated with the reciprocal dimension.</span>

<span class="sd">        For example, the reciprocal quantity name, &quot;inverse speed&quot;.</span>
<span class="sd">        This value cannot be updated.</span>

<span class="sd">        :returns: A string with the quantity name.</span>
<span class="sd">        :raises AttributeError: For non-quantitative controlled variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># &quot;&quot;&quot;</span>
        <span class="c1"># When assigning a value, the</span>
        <span class="c1"># quantity name must be consistent with the other</span>
        <span class="c1"># physical quantities specifying the reciprocal</span>
        <span class="c1"># grid dimension.</span>
        <span class="c1"># &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_reciprocal_quantity</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span>
                                                <span class="s1">&#39;reciprocal_quantity&#39;</span><span class="p">))</span>

    <span class="nd">@reciprocal_quantity</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">reciprocal_quantity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;This attribute is not yet implemented.&#39;</span><span class="p">)</span>

    <span class="c1"># @reciprocal_quantity.setter</span>
    <span class="c1"># def reciprocal_quantity(self, string = &#39;&#39;):</span>
    <span class="c1">#     ## To do: add a check for reciprocal quantity</span>
    <span class="c1">#     self.set_attribute(&#39;_reciprocal_quantity&#39;, string)</span>
<span class="c1"># --------------------------------------------------------------------------- #</span>

<span class="c1"># label</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the label associated with the dimension.</span>

<span class="sd">        The attribute is updated with a string containing the label, for</span>
<span class="sd">        example, ::</span>

<span class="sd">            &gt;&gt;&gt; x.label</span>
<span class="sd">            &#39;&#39;</span>
<span class="sd">            &gt;&gt;&gt; x.label = &#39;field strength&#39;</span>

<span class="sd">        :returns: A ``String`` containing the label.</span>
<span class="sd">        :raises TypeError: When the assigned value is not a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_label</span><span class="p">)</span>

    <span class="nd">@label</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_type_message</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">label</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;_label&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

<span class="c1"># reciprocal_label</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reciprocal_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the label associated with the reciprocal dimension.</span>

<span class="sd">        This attribute can be updated with a string</span>
<span class="sd">        containing the label of the reciprocal dimension,</span>
<span class="sd">        for example, the reciprocal label, &quot;inverse velocity&quot;.</span>

<span class="sd">        :returns: A ``string`` containing the label.</span>
<span class="sd">        :raises TypeError: When the assigned value is not a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_reciprocal_label</span><span class="p">)</span>

    <span class="nd">@reciprocal_label</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">reciprocal_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;_reciprocal_label&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

<span class="c1"># axis label</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axis_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a formatted string for displaying the label along the dimension.</span>

<span class="sd">        This supplementary attribute is convenient for labeling axes.</span>
<span class="sd">        For quantitative controlled variables, this attributes returns a</span>
<span class="sd">        string, &#39;label / unit&#39;,  if the `label` is not an empty string. If the</span>
<span class="sd">        `label` is an empty string, &#39;quantity / unitâ€™ is returned instead. Here</span>
<span class="sd">        `quantity` and `label` are the attributes of the :ref:`cv_api`</span>
<span class="sd">        instances described before, and `unit` is the unit associated with the</span>
<span class="sd">        control variable.</span>
<span class="sd">        For example, consider a temporal controlled variable where ::</span>

<span class="sd">            &gt;&gt;&gt; x.label</span>
<span class="sd">            &#39;field strength&#39;</span>
<span class="sd">            &gt;&gt;&gt; x.axis_label</span>
<span class="sd">            &#39;field strength / ( G)&#39;</span>

<span class="sd">        For non-quantitative controlled variables, this attribute returns</span>
<span class="sd">        the `label`.</span>

<span class="sd">        :returns: A ``String``.</span>
<span class="sd">        :raises AttributeError: When assigned a value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantity</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_axis_label</span><span class="p">(</span>
                <span class="n">label</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_unit</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">made_dimensionless</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_dimensionless_unit</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

<span class="c1"># data_structure()</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ControlledVariable object as a json object.</span>

<span class="sd">        This supplementary attribute is useful for a quick preview of the data</span>
<span class="sd">        structure. The attribute cannot be modified. ::</span>

<span class="sd">            &gt;&gt;&gt; print(x.data_structure)</span>
<span class="sd">            {</span>
<span class="sd">                &quot;reciprocal&quot;: {</span>
<span class="sd">                    &quot;reference_offset&quot;: &quot;5.0 T^-1&quot;,</span>
<span class="sd">                    &quot;origin_offset&quot;: &quot;400.0 ÂµT^-1&quot;</span>
<span class="sd">                },</span>
<span class="sd">                &quot;number_of_points&quot;: 5,</span>
<span class="sd">                &quot;sampling_interval&quot;: &quot;0.1 G&quot;,</span>
<span class="sd">                &quot;origin_offset&quot;: &quot;100000.0 G&quot;,</span>
<span class="sd">                &quot;reverse&quot;: true,</span>
<span class="sd">                &quot;quantity&quot;: &quot;magnetic flux density&quot;,</span>
<span class="sd">                &quot;label&quot;: &quot;field strength&quot;</span>
<span class="sd">            }</span>

<span class="sd">        :raises AttributeError: When modified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dictionary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_python_dictionary</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">ensure_ascii</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">sort_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

<span class="c1"># =========================================================================== #</span>
<span class="c1">#                                  Methods                                    #</span>
<span class="c1"># =========================================================================== #</span>

<span class="c1"># _get_python_dictionary()</span>
    <span class="k">def</span> <span class="nf">get_python_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return the ControlledVariable object as a python dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">_get_python_dictionary</span><span class="p">()</span>

<span class="c1"># is_quantitative()</span>
    <span class="k">def</span> <span class="nf">is_quantitative</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify if the control variable dimension is quantitative.</span>

<span class="sd">        Returns `True`, if the control variable is quantitative,</span>
<span class="sd">        otherwise `False`.</span>

<span class="sd">        :returns: A Boolean.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

<span class="c1"># to()</span>
<div class="viewcode-block" id="ControlledVariable.to"><a class="viewcode-back" href="../../api/csdfpy.ControlledVariable.html#csdfpy.ControlledVariable.to">[docs]</a>    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the unit of the controlled variable coordinates to `unit`.</span>

<span class="sd">        This method is a wrapper of the `to` method from the</span>
<span class="sd">        `Quantity &lt;http://docs.astropy.org/en/stable/api/\</span>
<span class="sd">        astropy.units.Quantity.html#astropy.units.Quantity.to&gt;`_ class</span>
<span class="sd">        and is only `valid` for physical dimensions.</span>

<span class="sd">        For example, if ::</span>

<span class="sd">            &gt;&gt;&gt; print(x.coordinates)</span>
<span class="sd">            [0.4 0.3 0.2 0.1 0. ] G</span>
<span class="sd">            &gt;&gt;&gt; x.to(&#39;ÂµT&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(x.coordinates)</span>
<span class="sd">            [40. 30. 20. 10.  0.] uT</span>

<span class="sd">        :params: `unit` : A string containing a unit with the same</span>
<span class="sd">            dimensionality as the controlled variable coordinates.</span>
<span class="sd">        :raise AttributeError: For non-quantitative controlled variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span> <span class="ow">in</span> <span class="n">_quantitative_variable_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_type_message</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">unit</span><span class="p">)))</span>

            <span class="k">if</span> <span class="n">unit</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;ppm&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;_dimensionless_unit&#39;</span><span class="p">,</span> <span class="n">_ppm</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span>
                    <span class="s1">&#39;_unit&#39;</span><span class="p">,</span> <span class="n">_check_unit_consistency</span><span class="p">(</span>
                        <span class="mf">1.0</span><span class="o">*</span><span class="n">string_to_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">unit</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">unit</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gcv</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;_equivalencies&#39;</span><span class="p">,</span> <span class="n">equivalencies</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">_attribute_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_type</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">))</span></div></div>
</pre></div>

           </div>
           
          </div>
    <a href="https://github.com/DeepanshS/csdfpy">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub">
    </a>

          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Deepansh J. Srivastava

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../_static/copybutton.js"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>